import { NextResponse } from 'next/server';
import { validateGeneratedCode, autoFixCode } from '@/utils/codeValidator';
import {
  analytics,
  generateRequestId,
  categorizeError,
  PerformanceTracker,
} from '@/utils/analytics';
import { isMockAIEnabled, mockComponentResponse } from '@/utils/mockAI';
import { logAPI } from '@/utils/debug';

// Vercel serverless function config
export const maxDuration = 300;
export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  // ============================================================================
  // MOCK AI MODE - Return instant mock response if enabled
  // ============================================================================
  if (isMockAIEnabled()) {
    logAPI('POST', '/api/ai-builder', { mock: true });
    return NextResponse.json({
      code: mockComponentResponse.code,
      explanation: mockComponentResponse.explanation,
      name: 'Mock Component',
      _mock: true,
      _mockWarning: 'Mock AI Mode is enabled. Set NEXT_PUBLIC_MOCK_AI=false for real AI.',
    });
  }

  const requestId = generateRequestId();
  const perfTracker = new PerformanceTracker();

  try {
    const body = await request.json();
    const { 
      prompt, 
      conversationHistory, 
      currentAppState, 
      image, 
      isModification 
    } = body;
    perfTracker.checkpoint('request_parsed');

    // Log request start after parsing body
    analytics.logRequestStart('ai-builder', requestId, {
      hasConversationHistory: !!conversationHistory,
      hasImage: !!image
    });

    // 1. Prepare Input for Titan Pipeline
    // Extract current code from currentAppState or use empty if new
    const currentCode = currentAppState?.files?.[0]?.content || null;
    const files = currentAppState?.files || [];

    // Import the service dynamically to ensure env vars are ready
    const { getTitanPipelineService } = await import('@/services/TitanPipelineService');
    const titan = getTitanPipelineService();

    // Construct Pipeline Input
    const pipelineInput = {
      files: files,
      instructions: prompt,
      currentCode: currentCode,
      appContext: {
        name: currentAppState?.name,
        techStack: ['react', 'tailwind', 'typescript', 'lucide-react'] 
      },
      assets: {
        images: image ? [image] : []
      }
    };

    // 2. Run Pipeline
    const result = await titan.runPipeline(pipelineInput);
    perfTracker.checkpoint('pipeline_complete');

    // 3. Map Result to Response
    
    // Check for Autonomy/Research result
    if (result.strategy.mode === 'RESEARCH_AND_BUILD') {
        const outputContent = result.files[0]?.content || '// No code generated from research';
        
        const responseData = {
          name: 'Researched Solution',
          explanation: 'I researched this task and built a solution.',
          code: outputContent,
          files: result.files,
          changeType: 'MODIFICATION', 
          summary: 'Autopoietic Agent successfully researched and implemented the solution.'
        };

        // Log completion
        analytics.logRequestComplete(requestId, {
           modelUsed: 'titan-pipeline-autonomy',
           responseLength: outputContent.length,
           validationRan: true,
           metadata: { mode: 'RESEARCH_AND_BUILD' }
        });

        return NextResponse.json(responseData);
    }

    // Normal modes (CREATE, MERGE, EDIT)
    const mainFile = result.files.find(f => f.path.endsWith('App.tsx') || f.path.endsWith('Component.tsx')) || result.files[0];
    const generatedCode = mainFile?.content || '';
    
    // Attempt to extract name/explanation if available in manifest, else default
    const name = currentAppState?.name || 'Generated App';
    const explanation = 'Generated by Titan Pipeline'; 

    analytics.logRequestComplete(requestId, {
      modelUsed: 'titan-pipeline',
      responseLength: generatedCode.length,
      validationRan: true,
      metadata: {
        mode: result.strategy.mode,
        componentName: name,
        codeLength: generatedCode.length
      }
    });

    return NextResponse.json({
      name,
      explanation,
      code: generatedCode,
      files: result.files,
      changeType: isModification ? 'MODIFICATION' : 'NEW_APP',
      summary: result.warnings.length > 0 ? `Completed with warnings: ${result.warnings.join(', ')}` : 'Successfully built application.',
      layoutManifest: result.manifests?.[0]
    });

  } catch (error) {
    console.error('Error in AI builder route:', error);
    analytics.logRequestError(requestId, error as Error, categorizeError(error as Error));
    
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process request' },
      { status: 500 }
    );
  }
}
