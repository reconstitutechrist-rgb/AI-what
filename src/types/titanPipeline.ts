/**
 * Titan Pipeline Types
 * Includes: Vision DNA, Physics, Assets, and UI State Management
 */

import type { AppFile } from '@/types/railway';
import type { CritiqueResult } from '@/types/visualCritic';
import type { AgentCommand, SuspendedExecution } from '@/types/autonomy';

// ============================================================================
// REPO CONTEXT TYPES (Ultimate Developer)
// ============================================================================

/**
 * A reusable code pattern extracted from the repository.
 * Used by the Builder to replicate existing patterns rather than hallucinating new ones.
 */
export interface PatternTemplate {
  /** Descriptive name, e.g., "Data Fetching Hook" */
  name: string;
  /** Source file path, e.g., "src/hooks/useApi.ts" */
  sourceFile: string;
  /** The actual template code snippet */
  codeSnippet: string;
}

/**
 * Repository context extracted by the RepoAnalyst.
 * Provides deep understanding of existing codebases for style-consistent generation.
 */
export interface RepoContext {
  /** Content hash for cache invalidation — skip re-analysis if unchanged */
  contentHash: string;
  /** Freeform style guide generated by AI — captures nuance like import ordering */
  styleGuide: string;
  /** Reusable code patterns extracted from the repo */
  patternLibrary: PatternTemplate[];
  /** Files central to the architecture (high import count / core services) */
  criticalFiles: string[];
  /** Detected tech stack (e.g., "Next.js", "Tailwind", "Prisma") */
  techStack: string[];
  /** If true, modifications to criticalFiles require tests first (Zero-Bug integration) */
  criticalFilesRequireTests: boolean;
}

// ============================================================================
// UI & STATE MANAGEMENT TYPES
// ============================================================================

export type PipelineStepName =
  | 'routing'
  | 'surveying'
  | 'architecting'
  | 'physicist'
  | 'photographer'
  | 'assembling';

export type PipelineStepStatus = 'idle' | 'running' | 'completed' | 'error';

export const PIPELINE_STEP_LABELS: Record<PipelineStepName, string> = {
  routing: 'Analyzing Intent',
  surveying: 'Reverse Engineering UI',
  architecting: 'Building Structure',
  physicist: 'Extracting Motion',
  photographer: 'Generating Material Assets',
  assembling: 'Synthesizing Code',
};

export interface PipelineProgress {
  currentStep: PipelineStepName;
  status: PipelineStepStatus;
  steps: Record<PipelineStepName, { status: PipelineStepStatus; message?: string }>;
}

export const createInitialProgress = (): PipelineProgress => ({
  currentStep: 'routing',
  status: 'idle',
  steps: {
    routing: { status: 'idle' },
    surveying: { status: 'idle' },
    architecting: { status: 'idle' },
    physicist: { status: 'idle' },
    photographer: { status: 'idle' },
    assembling: { status: 'idle' },
  },
});

// ============================================================================
// INSPECTOR BRIDGE TYPES (used by inspectorBridge.ts + LayoutCanvas)
// ============================================================================

/** Message sent from inspector script in Sandpack iframe to parent */
export interface InspectorMessage {
  type: 'COMPONENT_SELECTED';
  /** data-id attribute value */
  id: string;
  /** HTML tag name */
  tagName: string;
  /** outerHTML of the selected element */
  outerHTML: string;
  /** Bounding rect relative to iframe viewport */
  rect: {
    top: number;
    left: number;
    width: number;
    height: number;
  };
}

/** State returned by the useInspectorBridge hook */
export interface InspectorBridgeState {
  /** ID of the currently selected component (data-id value) */
  selectedComponentId: string | null;
  /** outerHTML of the selected component */
  selectedHTML: string | null;
  /** Tag name of the selected component */
  selectedTagName: string | null;
  /** Bounding rect for positioning FloatingEditBubble */
  selectedRect: { top: number; left: number; width: number; height: number } | null;
  /** Clear selection */
  clearSelection: () => void;
}

// ============================================================================
// INPUT / CONTEXT TYPES
// ============================================================================

/** App context passed from the global store for personalized generation */
export interface AppContext {
  name?: string;
  colorScheme?: string;
  primaryColor?: string;
  style?: string;
}

export interface FileInput {
  filename: string;
  mimeType: string;
  base64: string;
}

export interface PipelineInput {
  files: FileInput[];
  instructions: string;
  currentCode: string | null;
  appContext?: AppContext;
  /** Skip the vision healing loop (default: false) */
  skipHealing?: boolean;
  /** Pre-analyzed repo context for style-consistent code generation (Ultimate Developer mode) */
  repoContext?: RepoContext;
}

// ============================================================================
// PIPELINE LOGIC TYPES
// ============================================================================

/** A node in the Surveyor's recursive DOM tree output */
export interface DomTreeNode {
  type: string;
  id?: string;
  styles?: Record<string, string>;
  text?: string;
  children?: DomTreeNode[];
  hasCustomVisual?: boolean;
  extractionBounds?: {
    top: number;
    left: number;
    width: number;
    height: number;
  };
  iconSvgPath?: string;
  /** Allow additional properties from AI output */
  [key: string]: unknown;
}

export interface VisualManifest {
  file_index: number;
  canvas?: {
    width: number;
    height: number;
    background?: string;
  };
  global_theme?: {
    colors?: string[];
    fonts?: string[];
    dom_tree?: DomTreeNode;
    assets?: string[];
  };
  measured_components: Array<{
    type: string;
    text?: string;
    box: { x: number; y: number; w: number; h: number };
    colors?: string[];
  }>;
}

export interface MotionPhysics {
  component_motions: Array<{
    id: string;
    velocity: { x: number; y: number };
    mass: number;
    spring: { stiffness: number; damping: number };
  }>;
}

export interface ComponentStructure {
  layout_strategy: 'flex' | 'grid' | 'absolute';
  tree: Array<{
    type: string;
    id: string;
    props: Record<string, any>;
    children?: any[];
  }>;
}

export interface MergeStrategy {
  mode: 'CREATE' | 'MERGE' | 'EDIT' | 'RESEARCH_AND_BUILD';
  base_source: 'codebase' | 'file_0' | null;
  file_roles: string[];
  execution_plan: {
    measure_pixels: number[];
    extract_physics: number[];
    preserve_existing_code: boolean;
    generate_assets?: Array<{
      name: string;
      description: string;
      vibe?: string;
      type?: 'texture' | 'image' | 'icon' | 'hdri' | 'environment';
    }>;
    /** Signals 3D mode — Builder appends R3F-specific prompt */
    enable_3d?: boolean;
  };
}

// ============================================================================
// RESULTS
// ============================================================================

export interface PipelineResult {
  files: AppFile[];
  strategy: MergeStrategy;
  manifests: VisualManifest[];
  physics: MotionPhysics | null;
  warnings: string[];
  stepTimings: Record<string, number>;
  /** Visual critique result (if evaluated) */
  critique?: CritiqueResult;
  /** Vision healing loop result (if run) */
  healingResult?: {
    fidelityScore: number;
    iterations: number;
    stopReason: string;
    usedPatching?: boolean;
  };
  /** Avatar Protocol: Command to be executed by the client */
  command?: AgentCommand;
  /** Avatar Protocol: State to persist while waiting for feedback */
  suspendedState?: SuspendedExecution;
}

export interface LiveEditResult {
  success: boolean;
  error?: string;
  updatedCode?: string;
}

// ============================================================================
// OMNICHAT TYPES
// ============================================================================

/** A single message in the OmniChat conversation history */
export interface OmniConversationMessage {
  role: 'user' | 'assistant';
  content: string;
}

/** Request body for the OmniChat endpoint */
export interface OmniChatRequest {
  message: string;
  conversationHistory: OmniConversationMessage[];
  currentCode: string | null;
  appContext?: AppContext;
}

/** Action the AI decides to take after processing a message */
export type OmniChatAction = 'pipeline' | 'autonomy' | 'live-edit' | 'none';

/** Response from the OmniChat endpoint */
export interface OmniChatResponse {
  reply: string;
  action: OmniChatAction;
  actionPayload?: {
    instructions: string;
    selectedDataId?: string;
    /** Skill ID from cache hit — used to update quality score after critique */
    cachedSkillId?: string;
  };
}
